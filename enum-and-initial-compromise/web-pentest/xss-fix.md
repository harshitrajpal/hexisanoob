# XSS fix

1. **Input sanitization**. Demo:\
   text.replace("\<script>","#");

But it can be bypassed using a number of other payloads like \<img src=a onerror=alert("xss")>

It is a loosing strategy but can be implemented cleverly to block major malicious inputs.

2. **Using HttpOnly cookie**

**Set-Cookie: key=value; Expires=\<Date>; Secure; Httponly;**

Secure in cookie means the cookie will only be sent over HTTPS. but doesn't help against XSS

HttpOnly means JS running on page doesn't have access to that particular piece of cookie data. Instead its only accessible by the server itself.\
So, if \<script>alert(document.cookie)\</script> is run by an attacker, it will omit any cookie which has HttpOnly set.

Uses: When server is trying to store something sensitive like Session ID, server admin can mark that cookie as HttpOnly and then JS won't be able to access it.



3. XSS protection Header

X-XSS-Protection: 0/1

Sort of a message from server which tells the web browser that if you have any special features ( that are designed to detect things that look like XSS, you should turn them on or not turn them on.

So, for example if a URL is example.com?name=Harshit

and X-XSS-Protection: 1, The page loads normally.

But if, URL is example.com?name=\<script>alert(1)\</script>

and X-XSS-Protection: 1, The browser activates its security mechanism against the attack. This security mechanism could be Content Security Policy or some other thing like XSS filter mechanism depending on browser.

**Enable in Nginx**

```nginx
add_header X-XSS-Protection "1; mode=block" always;
```

