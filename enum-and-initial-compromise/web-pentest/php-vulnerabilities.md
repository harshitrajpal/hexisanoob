# PHP Vulnerabilities

PHP is a dinosaur now. But still relevant even in the modern web infrastructure. When we talk about PHP, we talk about dynamic back-end logic that resembles C in a way, and gives programmatic functionality to static HTML pages.

Ahh, good old Facebook days when PHP was super heavy and one of the key languages on the main website.

<figure><img src="../../.gitbook/assets/image (164).png" alt=""><figcaption></figcaption></figure>

But soon enough people realized that PHP had inherent vulnerabilities that makes it super easy for an attacker to break into it and moved on to modern Javascript frameworks.

Let's talk about such vulnerabilities for a bit before moving on.

#### PHP Type Juggling

PHP will do anything to match with a loose comparison. When I say loose comparison it means the double equal sign (==). A strictly equal sign would be the triple equal (===). But if the backend is using double equal (developer habit who use other programming languages frequently) we would see some of the following results:

0 == "0"

0 == null

"0e1234" == "0e4567"  (math quirk. anything multiplies by 0 is 0. Yeah, PHP doesn't care if it is a string. It will first convert it to a format it understands then compare it making them equal)

0 == "asdf"

$arr == array(); -> md5($arr) == md5("Array")

Imagine this: If two hashes are starting from the same "0e..." value, they will be the same. This defeats the purpose of password hashing (as in unique strings for each unique password). By this command you'll see various strings starting with 0e. PHP will compare them and tell that they're equal.

`for i in {1..4000}; do echo $i | md5sum ; done | grep ^0e`

#### PHP - File Inclusion

require, require\_once, include functions would import another PHP file. This can be easily cracked.

eg: require $\_GET\['page] . ".php";

This would allow includion of a file from URL. eg: example.com?page=index

This is problemmatic since we can easily provide any other file to be included. Even use techniques like null byte to include a non-PHP files too.



#### PHP - Stream filters

PHP also has its own URL schema=> php://...

The purpose of this URL schema is to filter some output like remove HTML tags or endode data in base64. For example, see the following script which filters out HTML tags except bold, italics and underline (\<b>,\<i>,\<u>)

```
$fp = fopen('php://output', 'w');
stream_filter_append(
$fp,
'string.strip_tags',
STREAM_FILTER_WRITE,
array('b','i','u'));
fwrite($fp,"<b>bolded</b> enlarged to a <h1>level 1 heading</h1>\n");
```

Interesting thing to note here is that we can use this php://... URL schema to extract any data that we want! Now the filter is supposed to format a PHP code and perform functions on it, right? But what if the data in stream is not PHP? Let's say base64. Then the filter won't format anything and parse all the raw data!

For example, I want flag.txt file in / directory and base64 encode it. I'd do this:

`php://filter/convert.base64-encode/resource=/flag.txt`

This would extract flag.txt in base64 and send to browser directly.

This is a good way to leak source code of a PHP web application! in a CTF I encountered a problem where I had to extract a flag hidden in PHP source code. include() function was fetching a file. I craffter the payload like this:

`http://site.com/index.php?page=php://filter/convert.base64-encode/resource=flag`

<figure><img src="../../.gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

And then after deecoding this base64 to readable text, I got the flag (and the PHP source code for flag.php file)

We can even fetch binaries from the server like this. Then do:

`pbpaste | bsae64 -D > foo.bin`

`file foo.bin`

